\chapter{Implementation of the Backend}
\label{backendimplementation}
\index{Object-oriented programming}
\index{Aspect-oriented programming}
\index{OWLAPI}
To implement the backend side of the framework a combination of object-oriented
programming (OOP) and aspect-oriented programming (AOP) was chosen.
AOP was applied with the
intention to improve the development of the change interception mechanism of the shared
ontology described in \ref{sharedOntologyImpl} and security related concerns as AOP
is suited well for implementing cross-cutting concerns.

To support the development procedure unit tests for all modules were implemented to
ensure components remain functional in the course of the development.

The code convention was adapted to the OWLAPI's to ease entry for beginners that
are familiar with the OWLAPI.


%%%%%%%%%%%%%%%%%%%%%%%%
\section{Technologies}
This section describes the technologies used in this project, reasons
why they have been chosen and experiences in the course of the development.

\subsection{AspectJ}
\index{AspectJ}
\index{Aspect-oriented programming}
AspectJ\footnote{AspectJ \url{http://eclipse.org/aspectj/}} is an open-source
project of the eclipse foundation and extends Java with AOP.
AspectJ is great for implementing tracing logging or
other security related concerns.

In the context of the Replica Framework it was meant to implement 
change interception at first. During the course of the project the 
AspectJ change interception mechanism was replaced with native Java 
code for practical reasons. Although AspectJ is not thoroughly used anymore
in the project it is still included as it can be used to implement security
and logging issues if needed by the developer. The main interface of the
shared ontology is prepared to allow easy creation of aspects in 
regard to shared object access. All shared object methods have a 
special annotation defined by the marker interface \emph{ProxyMethod}.
Additionally methods which modify the shared ontology object carry the
\emph{PropagatingMethod} annotation as these methods require change
propagation as shown in listing \ref{applyChange}.

A major drawback of using AspectJ in this project was the impact on
performance and memory usage when implementing change interception and
propagation with AspectJ.

\subsection{Eclipse Communication Framework}
\index{ECF}
The Eclipse Communication Framework\footnote{Eclipse Communication 
Framework \url{http://www.eclipse.org/ecf/}} (ECF) is a mature framework for 
building distributed servers, applications and tools. In contrast to 
other communication frameworks does ECF not implement a single 
communication protocol but relies on protocol independence instead. It 
is therefore an abstraction of many well known communication 
techniques and protocols. This framework implements a sophisticated 
extendable model which hides underlying protocols with unifying APIs 
for communication functionalities. These include currently APIs for
file transfer, implementing remote services, presence, service 
discovery, messaging and object replication. ECF is actively developed,
has a lot of components and features, along with the fact that the protocol
independence and extendability principle offers a lot of flexibility 
this was the communication framework of choice for this project.

A single but important shortcoming of ECF is the fragmented and 
incomplete documentation. For many components there is neither an official
nor an unofficial documentation available which had a significant 
impact on the progress of the project development.

%%%%%%%%%%%%%%%%%%%%%%%%
\section{Modules}
\index{OSGi}
Modules represent a separation of concerns by packing functionality in logical units. Modular
Programming therefore allows to build large and complex applications while improving
maintainability.

The framework components are organized in modules which are implemented
as OSGi\footnote{The OSGi Alliance is a worldwide consortium of technology innovators that
advances a proven and mature process to create open specifications that enable
the modular assembly of software built with Java technology.} Bundles.
Bundles are a collection of Java source files together with libraries and meta information.
A special file \emph{MANIFEST.MF} holds meta information such as bundle name and version,
vendor name, required execution environment, exported packages and dependencies.

Dependency management is a very important feature of the OSGi framework.
This section offers an overview of all Replica Framework modules and
describes the \emph{Core} and \emph{Communication} modules in detail. These modules are
entry points to the Replica Framework.

\subsection{Core module}
The core module is the one on which all other modules depend on.
It contains an implementation of the Shared Ontology described in section \ref{sharedOntology}
and the class \emph{OWLReplicaManager} which is the entry point to the framework.
\emph{OWLReplicaManager} has the same functionality as the \emph{OWLManager}
in the \index{OWLAPI}OWLAPI.

Moreover the core module contains a builder which generates an abstract shared ontology
implementation. This builder can be used from the command line and was made
for the purpose of reducing maintenance costs in case the OWLAPI is updated.

\subsection{Communication module}
\label{communicationmodule}
The communication module contains all communication-related components of
the framework. The \emph{CommManager} can be used to create connection instances
and is required on both the client and server side.

In addition to that does the communication module include the \emph{channel} package.
This package contains an implementation of the \emph{SignalChannel} which is a slight
addition to the ECF \emph{Datashare API} message concept. \emph{SignalChannel} is meant
to be used in application development when communication requires transmission
of events or other relatively small typed messages.


\newpage


\subsection{Overview}
This sub section offers an overview of all Replica Framework modules in
table \ref{frameworkplugins}.
\begin{table}[h]\centering
	\caption{Overview of all Replica Framework plugins}
	\label{frameworkplugins}
	\begin{tabular}{ | c | p{9cm} | c | }
		\hline
			\begin{tabular}{ c }
				\textbf{\emph{Bundle Postfix}},\\
				\textbf{Module Name}
			\end{tabular} & \textbf{Description} & \textbf{Dependencies} \\ \hline
		\begin{tabular}{ c }
			\emph{owlapi}
		\end{tabular} & The OWLAPI lib Plug-in plugin contains the patched version of
			the OWLAPI library. & - \\ \hline
		\begin{tabular}{ c }
			\emph{core}
		\end{tabular} & The core plugin contains the Shared Ontology Implementation and Shared Ontology
			builder which is required when applying OWLAPI updates. &  \emph{owlapi} \\ \hline		
		\begin{tabular}{ c }
			\emph{app}
		\end{tabular} & The application plugin contains interfaces and classes required
			to build applications like server or client instances. & \emph{core} \\ \hline
		\begin{tabular}{ c }
			\emph{comm}
		\end{tabular} & The communication module contains all communication related components
			of the Replica Framework. Especially the
			\emph{CommManager} is included in this plugin. & \emph{core} \\ \hline
		\begin{tabular}{ c }
			\emph{dictionary}
		\end{tabular} & The dictionary plugin plugin holds interfaces and classes
			related to the Dictionary concept of the Replica Framework. & \emph{core} \\ \hline
		\begin{tabular}{ c }
			\emph{fragments}
		\end{tabular} & The fragments plugin bundle incorporates the Shared Ontology
			Fragment concept related components of the Replica Framework. & \emph{core} \\ \hline
		\begin{tabular}{ c }
			\emph{changes}
		\end{tabular} & The Change Management plugin
			holds special implementations of the \emph{OWLReplicaOntology}
			interface that actualize all necessary parts of the
			Change Management concept of the framework. & \emph{core}, \emph{fragments} \\ \hline
		\begin{tabular}{ c }
			\emph{neonplugin}
		\end{tabular} & The NeOn Toolkit plugin includes the implementation of the
			NeOn Toolkit plugin. & \emph{core}, \emph{comm} \\ \hline
		\begin{tabular}{ c }
			\emph{plicies}
		\end{tabular} & This plugin
			contains components required for \emph{policy management}.
			It has not yet been implemented at the time of writing.
			& \emph{core} \\ \hline
		\begin{tabular}{ c }
			\emph{query}
		\end{tabular} & This plugin holds Query Management related
			parts. It has not yet been implemented at the time of writing. & \emph{core} \\ \hline
		\begin{tabular}{ c }
			\emph{demo}
		\end{tabular} & This plugin contains an implementation of a
			standalone demonstrator application that presents features of
			the Replica Framework. & \emph{core}, \emph{comm} \\ \hline
	\end{tabular}
\end{table}


\newpage


\section{Shared Ontology Implementation}
\label{sharedOntologyImpl}
The shared ontology object is a fundamental component of the framework.
The \emph{OWLReplicaOntology} interface is a facade combining the 
OWLAPI \emph{OWLOntology} interface with the ECF \emph{ISharedObject} interface.
To provide implementations of this interface was a challenging task.
As Java supports multiple inheritance only for interfaces it is impossible
to extend from existing implementations of both respective interfaces.
Consequently implementations can only extend from either the 
\emph{OWLOntology} or \emph{ISharedObject} implementations exclusively.
The problem is that the effort of implementing all methods of both interfaces and
maintaining these over time with updates of both the OWLAPI and ECF
is way too high.

The solution is to create an implementation that extends 
\emph{TransactionSharedObject} a reference implementation of the ECF
ISharedObject interface in combination with the proxy pattern.
As the implementation has to provide all \emph{OWLOntology} methods as well it
contains an ontology as an attribute. The method calls are then
delegated to this inner ontology object.
To simplify the process of creating such a class in case of an OWLAPI update
the framework provides a builder for an abstract class with the structure
described before.

\subsection{Change Interception}
Intercepting changes on the ontology instance is essential for the
implementation of a shared ontology and change management in the
context of distributed ontology system. At first AspectJ was used to
leverage the strength of crosscutting-concerns in AOP. The idea was
to intercept changes by declaring pointcuts containing all join points
that denote ontology changes. Filtering, modification and propagation
was implemented in corresponding advices then.

When implementing change management the complexity of the AOP approach
became unbearable. Aside from that crosscutting-concerns broke with
the principle of separation of concerns fundamental to modular programming.
Mixing both approaches was therefore problematic and impractical so
falling back to a traditional object-oriented programming solution was
the proper alternative. The solution was to intercept changes in the 
outer ontology proxy methods responsible for applying changes
before passing them to the inner ontology object as shown in listing
\ref{applyChange}. To avoid cycles when propagating changes, another
method is required which bypasses change processing and a distinction
between callers as shown in listing \ref{applyChangesSilent}.

This approach brought a slight performance improvement
as the AspectJ runtime was not required anymore and the amount
of method invocations was reduced.

%%%%%%%%%%%%%%%%%%%%%%%%
\section{Communication}
To implement a useful collaborative ontology development system it is not
enough to provide only a shared ontology. The framework should also provide
the means to build other components that support in the process of collaborative
ontology development.

Furthermore communication should be reliable and ideally fault-tolerant. This
was accomplished by transactional message propagation. ECF provides a
special \emph{ISharedObject} implementation called \emph{TransactionSharedObject}
for all-or-nothing, in-order messaging. Using this feature ensures that changes
are either applied correctly or dropped. No partial changes can be applied
which greatly reduces the risk of raising inconsistencies in case of communication
errors.

\subsection{Connection Management}
The main component which is used for connection management is the \emph{communication manager}.
It can be used to create multiple connections. A connection provides access
to the basic communication facilities. These include the ECF interfaces
for managing shared objects and messaging as well as the \emph{signal channel manager}.

\subsubsection{Connection Activity}
To avoid blocking methods when communicating asynchronously a mechanism
is needed which allows sending messages and reacting to a response
or a timeout later without waiting for the result.
A \emph{connection activity} represents a procedure in the context of a connection.

It contains a list of states and user-defined transitions between these
states.
%This is best explained with a simple example. Consider a client wants
%to add a new shared ontology.
%Therefore in terms of the communication two messages are necessary:
%(1) the client sends a request for a new shared object ID
%(2) the server responds the new ID.\\
%When the client sends the request \todo[inline]{code}

\subsection{Signals}
In some situations messaging may be restricted to sending simple typed
messages that trigger certain predefined tasks. For example refreshing
the screen or rebuilding an repository index. For this purpose \emph{Signals}
have been introduced which are asynchronous messaging based and allow
for sending plain typed messages without content or typed messages with
content.



%%%%%%%%%%%%%%%%%%%%%%%%
\section{Change Management}
\index{AspectJ}
Change management implementations are hidden behind the \emph{OWLReplicaOntology}
interface. The principle is that changes are intercepted before submitting
them to the Ontology object within the OWLReplicaOntology object and
processing them. The various components of that processing chain are
described in section \ref{changemanagement}.
At first AspectJ was used to realize ontology change interception.
A special marker interface called \emph{PropagatingMethod} indicates
which methods in the \emph{OWLReplicaOntology} have a modifying impact
and are therefore part of the change management.


%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{Applications}
The Replica Framework comes with three applications that make it possible
to use the framework.
This section describes the communication hosts briefly that
the Replica Framework includes.
These are the \emph{server}, \emph{client} and \emph{node} hosts.

\subsection{Server}
The \emph{server} application of the Replica Framework is a central spot for
clients to connect to and to hold meta information of all clients and
shared ontologies. That is why the server can also be seen as some kind
of \emph{shared ontology repository}.

Servers also manage the shared ontologies. For example when clients create a shared
ontology they need to retrieve a shared ontology ID from the server before.
Whenever a client needs to access a shared ontology it has to connect to
a server.

\subsection{Client}
The \emph{client} application of the Replica Framework can retrieve lists of
shared ontology IDs from the server. It is used to communicate with the
server for accessing shared ontologies.

In addition to that it allows to retrieve and add \emph{shared ontology groups}
which are meant to simplify the implementation of shared ontology management.
Such a group consists of a set of shared ontologies.
A shared ontology can also occur in more than one group.

\subsection{Node}
A \emph{node} is a special host that combines the functionality of
servers and clients. Its primary purpose is to ease the development of
peer-to-peer applications in the context of Distributed Ontology Systems.
The implementation is basically an instance of a server and a client
hidden behind the \emph{ReplicaOntologyNode} interface.


\subsection{System Configuration}
To configure the Replica Framework a configuration has to be specified.
This configuration consists of sections for each component. Wherever
possible reasable defaults are used so that the supplied configuration
overwrites configuration values. This principle is meant to ease system
configuration.

Support of runtime changes of configuration values is preferred wherever
possible. For example the configuration for the creation of connections
with the \emph{CommManager} of the communication module described in section
\ref{communicationmodule} can be changed after the \emph{CommManager}
has been started. This configuration sets defaults for
new connections but specific parts of it or the whole configuration of
a connection can also be supplied to the \emph{CommManager} when a connection
is about to be created.


%\begin{table}[H]
%\centering
%\footnotesize % alternativ \tiny \scriptsize \footnotesize \normalsize \large ...
%\begin{tabular}{|c|c|c|c|c|}\hline
%\bf Filename & \bf Originating project & \bf Used in bundles & \bf License & \bf Description	\\ \hline
%org.aspectj.runtime.jar  &  AspjectJ &  all &  EPL 1.0  &  AspectJ runtime	environment 	\\ \hline
%org.aspectj.weaver.jar  &  AspjectJ &  all &  EPL 1.0  &  AspectJ weaver 	\\ \hline
%ajde.jar  &  AspjectJ &  all &  EPL 1.0  &  AspectJ weaver 	\\ \hline
%\end{tabular}
%\caption{Table of libraries used}
%\label{hd44780befehle}
%\end{table}
